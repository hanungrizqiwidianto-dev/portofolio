<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async Patterns & Promises - Node.js Development</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>

<body>
    <div id="sidebarContainer"></div>

    <div class="container">
        <main class="content">
            <div class="page-header">
                <div class="breadcrumb">
                    <a href="../../index.html">Home</a>
                    <span>/</span>
                    <a href="#">Node.js Development</a>
                    <span>/</span>
                    <span>Async Patterns & Promises</span>
                </div>
                <h1><i class="fas fa-sync-alt"></i> Asynchronous Programming in Node.js</h1>
                <p class="page-description">Master callbacks, Promises, async/await, and event-driven patterns for
                    non-blocking I/O operations.</p>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-history"></i> Callbacks (Old Pattern)</h2>
                <pre><code>const fs = require('fs');

// Callback pattern
fs.readFile('file.txt', 'utf8', (err, data) => {
    if (err) {
        console.error('Error:', err);
        return;
    }
    console.log(data);
});

// Callback hell (pyramid of doom)
fs.readFile('file1.txt', 'utf8', (err, data1) => {
    if (err) return console.error(err);
    
    fs.readFile('file2.txt', 'utf8', (err, data2) => {
        if (err) return console.error(err);
        
        fs.readFile('file3.txt', 'utf8', (err, data3) => {
            if (err) return console.error(err);
            
            console.log(data1, data2, data3);
        });
    });
});</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-check"></i> Promises</h2>
                <pre><code>const fs = require('fs').promises;

// Basic Promise
const readFilePromise = (filename) => {
    return new Promise((resolve, reject) => {
        fs.readFile(filename, 'utf8')
            .then(data => resolve(data))
            .catch(err => reject(err));
    });
};

// Promise chaining
fs.readFile('file1.txt', 'utf8')
    .then(data1 => {
        console.log('File 1:', data1);
        return fs.readFile('file2.txt', 'utf8');
    })
    .then(data2 => {
        console.log('File 2:', data2);
        return fs.readFile('file3.txt', 'utf8');
    })
    .then(data3 => {
        console.log('File 3:', data3);
    })
    .catch(err => {
        console.error('Error:', err);
    });

// Promise.all - Run in parallel
Promise.all([
    fs.readFile('file1.txt', 'utf8'),
    fs.readFile('file2.txt', 'utf8'),
    fs.readFile('file3.txt', 'utf8')
])
.then(([data1, data2, data3]) => {
    console.log(data1, data2, data3);
})
.catch(err => {
    console.error('Error:', err);
});

// Promise.race - First to complete
Promise.race([
    fetch('https://api1.com/data'),
    fetch('https://api2.com/data')
])
.then(response => response.json())
.then(data => console.log('First response:', data));

// Promise.allSettled - Wait for all, regardless of success/failure
Promise.allSettled([
    Promise.resolve(1),
    Promise.reject('error'),
    Promise.resolve(3)
])
.then(results => {
    results.forEach(result => {
        if (result.status === 'fulfilled') {
            console.log('Success:', result.value);
        } else {
            console.log('Failed:', result.reason);
        }
    });
});</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-rocket"></i> Async/Await (Modern Pattern)</h2>
                <pre><code>const fs = require('fs').promises;

// Basic async/await
async function readFiles() {
    try {
        const data1 = await fs.readFile('file1.txt', 'utf8');
        const data2 = await fs.readFile('file2.txt', 'utf8');
        const data3 = await fs.readFile('file3.txt', 'utf8');
        
        console.log(data1, data2, data3);
    } catch (err) {
        console.error('Error:', err);
    }
}

readFiles();

// Parallel execution with async/await
async function readFilesParallel() {
    try {
        const [data1, data2, data3] = await Promise.all([
            fs.readFile('file1.txt', 'utf8'),
            fs.readFile('file2.txt', 'utf8'),
            fs.readFile('file3.txt', 'utf8')
        ]);
        
        console.log(data1, data2, data3);
    } catch (err) {
        console.error('Error:', err);
    }
}

// Error handling in async/await
async function fetchUserData(userId) {
    try {
        const response = await fetch(`https://api.com/users/${userId}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const user = await response.json();
        return user;
    } catch (err) {
        console.error('Failed to fetch user:', err);
        throw err; // Re-throw if needed
    }
}

// Sequential vs Parallel
async function processUsers() {
    // Sequential (slower - waits for each)
    const user1 = await fetchUserData(1);
    const user2 = await fetchUserData(2);
    const user3 = await fetchUserData(3);
    
    // Parallel (faster - concurrent)
    const [user1, user2, user3] = await Promise.all([
        fetchUserData(1),
        fetchUserData(2),
        fetchUserData(3)
    ]);
}

// Top-level await (Node.js 14.8+)
const data = await fs.readFile('config.json', 'utf8');
const config = JSON.parse(data);</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-bolt"></i> Event Emitters</h2>
                <pre><code>const EventEmitter = require('events');

class DataProcessor extends EventEmitter {
    processData(data) {
        this.emit('start', data);
        
        // Simulate processing
        setTimeout(() => {
            if (data) {
                this.emit('data', { processed: data.toUpperCase() });
                this.emit('end');
            } else {
                this.emit('error', new Error('No data provided'));
            }
        }, 1000);
    }
}

const processor = new DataProcessor();

// Listen to events
processor.on('start', (data) => {
    console.log('Processing started:', data);
});

processor.on('data', (result) => {
    console.log('Processed data:', result);
});

processor.on('end', () => {
    console.log('Processing complete');
});

processor.on('error', (err) => {
    console.error('Error:', err);
});

// Trigger processing
processor.processData('hello world');

// Once - Listen only once
processor.once('start', () => {
    console.log('This runs only once');
});

// Remove listener
const callback = () => console.log('Event fired');
processor.on('data', callback);
processor.off('data', callback); // Remove specific listener</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-stream"></i> Streams</h2>
                <pre><code>const fs = require('fs');
const { Transform } = require('stream');

// Readable stream
const readStream = fs.createReadStream('large-file.txt', { encoding: 'utf8' });

readStream.on('data', (chunk) => {
    console.log('Received chunk:', chunk.length, 'bytes');
});

readStream.on('end', () => {
    console.log('Finished reading');
});

// Writable stream
const writeStream = fs.createWriteStream('output.txt');

writeStream.write('Hello\n');
writeStream.write('World\n');
writeStream.end('Done!\n');

// Pipe streams
fs.createReadStream('input.txt')
    .pipe(fs.createWriteStream('output.txt'));

// Transform stream
const upperCaseTransform = new Transform({
    transform(chunk, encoding, callback) {
        this.push(chunk.toString().toUpperCase());
        callback();
    }
});

fs.createReadStream('input.txt')
    .pipe(upperCaseTransform)
    .pipe(fs.createWriteStream('output-upper.txt'));

// Using async iterators with streams
async function processLargeFile() {
    const stream = fs.createReadStream('large-file.txt', { encoding: 'utf8' });
    
    for await (const chunk of stream) {
        console.log('Processing chunk:', chunk);
    }
}</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-code"></i> Advanced Patterns</h2>
                <pre><code>// Promise with timeout
function promiseWithTimeout(promise, timeout) {
    return Promise.race([
        promise,
        new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout')), timeout)
        )
    ]);
}

// Usage
try {
    const result = await promiseWithTimeout(
        fetch('https://api.com/slow-endpoint'),
        5000 // 5 seconds timeout
    );
} catch (err) {
    console.error('Request timeout or failed');
}

// Retry logic
async function retryOperation(operation, maxRetries = 3, delay = 1000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await operation();
        } catch (err) {
            if (i === maxRetries - 1) throw err;
            
            console.log(`Attempt ${i + 1} failed, retrying...`);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// Usage
const data = await retryOperation(() => fetch('https://api.com/data'));

// Async Queue
class AsyncQueue {
    constructor(concurrency = 1) {
        this.concurrency = concurrency;
        this.running = 0;
        this.queue = [];
    }
    
    async add(task) {
        while (this.running >= this.concurrency) {
            await new Promise(resolve => this.queue.push(resolve));
        }
        
        this.running++;
        
        try {
            return await task();
        } finally {
            this.running--;
            const resolve = this.queue.shift();
            if (resolve) resolve();
        }
    }
}

// Usage - limit concurrent operations
const queue = new AsyncQueue(3); // Max 3 concurrent

const urls = Array.from({ length: 100 }, (_, i) => `https://api.com/item/${i}`);

await Promise.all(
    urls.map(url => queue.add(() => fetch(url)))
);

// Promisify callback functions
const util = require('util');
const fs = require('fs');

const readFilePromise = util.promisify(fs.readFile);

// Now you can use async/await
const data = await readFilePromise('file.txt', 'utf8');</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-check-circle"></i> Best Practices</h2>
                <div class="tip-box">
                    <ul>
                        <li>✅ Prefer async/await over raw Promises for readability</li>
                        <li>✅ Always handle errors in async functions</li>
                        <li>✅ Use Promise.all() for parallel operations</li>
                        <li>✅ Avoid blocking the event loop with sync operations</li>
                        <li>✅ Use streams for large files and data</li>
                        <li>✅ Implement proper error handling and retries</li>
                        <li>✅ Set timeouts for external API calls</li>
                        <li>✅ Use EventEmitter for pub/sub patterns</li>
                        <li>✅ Limit concurrency for resource-intensive tasks</li>
                        <li>✅ Utilize util.promisify for legacy callback APIs</li>
                    </ul>
                </div>
            </div>

            <div class="navigation-links">
                <a href="nestjs.html" class="nav-link"><i class="fas fa-arrow-left"></i> Previous: NestJS</a>
                <a href="prisma.html" class="nav-link">Next: Prisma ORM <i class="fas fa-arrow-right"></i></a>
            </div>
        </main>
    </div>

    <script>
        fetch('../../index.html')
            .then(response => response.text())
            .then(html => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const sidebar = doc.querySelector('.sidebar');
                if (sidebar) {
                    document.getElementById('sidebarContainer').appendChild(sidebar);
                    const event = new Event('sidebarLoaded');
                    document.dispatchEvent(event);
                }
            });
    </script>
    <script src="../../js/main.js"></script>
</body>

</html>