<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goroutines & Concurrency - Go Development</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>

<body>
    <div id="sidebarContainer"></div>

    <div class="container">
        <main class="content">
            <div class="page-header">
                <div class="breadcrumb">
                    <a href="../../index.html">Home</a>
                    <span>/</span>
                    <a href="#">Go Development</a>
                    <span>/</span>
                    <span>Goroutines & Concurrency</span>
                </div>
                <h1><i class="fas fa-gopuram"></i> Goroutines & Concurrency</h1>
                <p class="page-description">Master Go's lightweight concurrency model with goroutines - the cornerstone
                    of efficient concurrent programming in Go.</p>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-info-circle"></i> What are Goroutines?</h2>
                <p>Goroutines are lightweight threads managed by the Go runtime. They're much cheaper than OS threads -
                    you can run thousands or even millions of goroutines concurrently. A goroutine is created by adding
                    the <code>go</code> keyword before a function call.</p>

                <div class="info-box">
                    <strong>Key Characteristics:</strong>
                    <ul>
                        <li>Extremely lightweight (~2KB initial stack size vs ~1MB for OS threads)</li>
                        <li>Multiplexed onto multiple OS threads by the Go scheduler</li>
                        <li>Non-blocking - goroutines can be created without blocking the main thread</li>
                        <li>Cooperative scheduling with work-stealing algorithm</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-code"></i> Basic Goroutine Example</h2>
                <pre><code>package main

import (
    "fmt"
    "time"
)

func sayHello(name string) {
    for i := 0; i < 3; i++ {
        fmt.Printf("Hello, %s! (iteration %d)\n", name, i+1)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // Normal function call - synchronous
    sayHello("World")
    
    // Goroutine - runs concurrently
    go sayHello("Goroutine")
    
    // Anonymous goroutine
    go func() {
        fmt.Println("Anonymous goroutine executed")
    }()
    
    // Wait for goroutines to finish
    time.Sleep(500 * time.Millisecond)
    fmt.Println("Main function finished")
}</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-sync"></i> WaitGroups - Proper Synchronization</h2>
                <p>Using <code>time.Sleep()</code> is not reliable. Use <code>sync.WaitGroup</code> to properly wait for
                    goroutines to complete:</p>

                <pre><code>package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Decrement counter when function returns
    
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    // Launch 5 workers
    for i := 1; i <= 5; i++ {
        wg.Add(1) // Increment counter before goroutine
        go worker(i, &wg)
    }
    
    wg.Wait() // Block until counter is 0
    fmt.Println("All workers completed")
}</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-rocket"></i> Advanced: Worker Pool Pattern</h2>
                <p>Worker pools limit concurrency and reuse goroutines for efficiency:</p>

                <pre><code>package main

import (
    "fmt"
    "sync"
    "time"
)

type Job struct {
    ID      int
    Data    string
}

type Result struct {
    Job    Job
    Output string
}

func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job.ID)
        time.Sleep(time.Second) // Simulate work
        
        results <- Result{
            Job:    job,
            Output: fmt.Sprintf("Processed: %s", job.Data),
        }
    }
}

func main() {
    const numWorkers = 3
    const numJobs = 10
    
    jobs := make(chan Job, numJobs)
    results := make(chan Result, numJobs)
    
    var wg sync.WaitGroup
    
    // Start workers
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }
    
    // Send jobs
    for j := 1; j <= numJobs; j++ {
        jobs <- Job{
            ID:   j,
            Data: fmt.Sprintf("Job-%d-data", j),
        }
    }
    close(jobs) // No more jobs
    
    // Wait for all workers to finish
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // Collect results
    for result := range results {
        fmt.Printf("Job %d: %s\n", result.Job.ID, result.Output)
    }
}</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-shield-alt"></i> Race Conditions & Mutex</h2>
                <p>Prevent race conditions when multiple goroutines access shared data:</p>

                <pre><code>package main

import (
    "fmt"
    "sync"
)

type SafeCounter struct {
    mu    sync.Mutex
    count map[string]int
}

func (c *SafeCounter) Increment(key string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count[key]++
}

func (c *SafeCounter) Value(key string) int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count[key]
}

func main() {
    counter := SafeCounter{count: make(map[string]int)}
    var wg sync.WaitGroup
    
    // Launch 1000 goroutines
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment("clicks")
        }()
    }
    
    wg.Wait()
    fmt.Println("Total clicks:", counter.Value("clicks"))
}

// Using sync.RWMutex for read-heavy workloads
type CachedData struct {
    mu    sync.RWMutex
    data  map[string]string
}

func (c *CachedData) Read(key string) (string, bool) {
    c.mu.RLock() // Multiple readers allowed
    defer c.mu.RUnlock()
    val, ok := c.data[key]
    return val, ok
}

func (c *CachedData) Write(key, value string) {
    c.mu.Lock() // Exclusive write lock
    defer c.mu.Unlock()
    c.data[key] = value
}</code></pre>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-check-circle"></i> Best Practices</h2>
                <div class="tip-box">
                    <h3>Do's:</h3>
                    <ul>
                        <li>✅ Always use WaitGroups or channels to synchronize goroutines</li>
                        <li>✅ Use buffered channels to prevent goroutine leaks</li>
                        <li>✅ Keep goroutines short-lived when possible</li>
                        <li>✅ Use context for cancellation and timeouts</li>
                        <li>✅ Limit concurrency with worker pools for resource-intensive tasks</li>
                        <li>✅ Use <code>go run -race</code> to detect race conditions</li>
                    </ul>

                    <h3>Don'ts:</h3>
                    <ul>
                        <li>❌ Don't use time.Sleep() for synchronization</li>
                        <li>❌ Don't forget to handle goroutine panics</li>
                        <li>❌ Don't create unbounded goroutines (can exhaust memory)</li>
                        <li>❌ Don't share memory without synchronization primitives</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h2><i class="fas fa-tools"></i> Practical Use Cases</h2>
                <div class="use-case">
                    <h3>1. Parallel HTTP Requests</h3>
                    <pre><code>func fetchURLs(urls []string) []string {
    var wg sync.WaitGroup
    results := make([]string, len(urls))
    
    for i, url := range urls {
        wg.Add(1)
        go func(index int, u string) {
            defer wg.Done()
            resp, err := http.Get(u)
            if err != nil {
                results[index] = fmt.Sprintf("Error: %v", err)
                return
            }
            defer resp.Body.Close()
            results[index] = fmt.Sprintf("%s: %d", u, resp.StatusCode)
        }(i, url)
    }
    
    wg.Wait()
    return results
}</code></pre>
                </div>

                <div class="use-case">
                    <h3>2. Background Tasks with Context</h3>
                    <pre><code>func backgroundProcessor(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Shutting down processor")
            return
        case <-ticker.C:
            fmt.Println("Processing batch...")
            // Process work here
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    
    go backgroundProcessor(ctx)
    
    time.Sleep(20 * time.Second)
    cancel() // Graceful shutdown
    time.Sleep(time.Second)
}</code></pre>
                </div>
            </div>

            <div class="navigation-links">
                <a href="channels.html" class="nav-link">Next: Channels & Select <i class="fas fa-arrow-right"></i></a>
            </div>
        </main>
    </div>

    <script>
        // Load sidebar
        fetch('../../index.html')
            .then(response => response.text())
            .then(html => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const sidebar = doc.querySelector('.sidebar');
                if (sidebar) {
                    document.getElementById('sidebarContainer').appendChild(sidebar);

                    // Dispatch event to notify sidebar is loaded
                    const event = new Event('sidebarLoaded');
                    document.dispatchEvent(event);
                }
            });
    </script>
    <script src="../../js/main.js"></script>
</body>

</html>